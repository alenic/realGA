#ifndef REALGA_MESSAGES_H
#define REALGA_MESSAGES_H

#include <stdexcept>
#include <string>
#include <sstream>

class RealGAException : public std::runtime_error
{
public:
    RealGAException(const std::string &msg)
        : std::runtime_error(msg) {}
};

#define REALGA_ERROR(condition, msg_expr)                                                                                         \
    if (condition)                                                                                                                \
    {                                                                                                                             \
        std::ostringstream oss;                                                                                                   \
        oss << msg_expr;                                                                                                          \
        throw RealGAException(std::string(__func__) + ": " + oss.str() + " (" + __FILE__ + ":" + std::to_string(__LINE__) + ")"); \
    }

#define DEBUG(msg)                        \
    {                                     \
        cout << "DEBUG: " << msg << endl; \
    }
#endif // REALGA_MESSAGES_H//Original chars:  44494
//Minified chars:  28195
//minified/original:  63.37%

#include<algorithm>
#include<stdexcept>
#include<numeric>
#include<sstream>
#include<stdlib.h>
#include<limits>
#include<stdio.h>
#include<fstream>
#include<unordered_set>
#include<cstddef>//forsize_t
#include<thread>
#include<random>
#include<string>
#include<cmath>
#include<vector>
#include<iostream>
#include<math.h>
namespace Stat{float randUniform();float randUniform(float lb,float ub);int randIndex(int n);float randGaussian(float mean,float sigma);void setSeed(unsigned int seed);void setSeedFromDevice();int randInteger(int min_val,int max_val);};
using namespace std;typedef enum{ROULETTE_WHEEL_SELECTION=1,TOURNAMENT_SELECTION}SelectionType;typedef enum{UNIFORM_CROSSOVER=1,LINEAR_CROSSOVER}CrossoverType;typedef enum{UNIFORM_MUTATION=1,GAUSSIAN_MUTATION}MutationType;typedef enum{NO_VERBOSE=0,SOFT_VERBOSE=1,HARD_VERBOSE=2}VerboseType;class RealGAOptions{public: RealGAOptions();~RealGAOptions();void setPopulationSize(size_t np);void setChromosomeSize(size_t nx);void setLowerBounds(const vector<float> &lb);void setUpperBounds(const vector<float> &ub);void setBounds(const vector<float> &lb,const vector<float> &ub);void setVerbose(int value);void setSeed(unsigned int seedValue);void setElitismFactor(float value);void setMutateDuplicatedFitness(bool value);void setSelectionType(string value);void setSelectionTournamentSize(int value);void setSelectionTournamentProbability(float value);void setMutationType(string value);void setMutationRate(float value);void setMutationGaussianPerc(float percDelta,float percMin);void setMutationUniformPerc(float percDelta,float percMin);void setCrossoverType(string value);void setSinglePointCrossoverIndex(int value);void checkOptions();size_t populationSize;size_t chromosomeSize;vector<float> lowerBounds;vector<float> upperBounds;int seed;VerboseType verbose;float elitismFactor;bool mutateDuplicatedFitness;SelectionType selectionType;size_t selectionTournamentSize;float selectionTournamentProbability;CrossoverType crossoverType;int crossoverindexA;MutationType mutationType;float mutationRate;float mutationUniformPercDelta;float mutationUniformPercMin;float mutationGaussianPercDelta;float mutationGaussianPercMin;};
using namespace std;class RealChromosome{public: vector<float> gene;float fitness;RealChromosome();RealChromosome(int n);RealChromosome(const RealChromosome &c);~RealChromosome();string toString()const;void randUniform(vector<float> &lb,vector<float> &ub);void randUniform(int i,vector<float> &lb,vector<float> &ub);void randGaussian(float mean,float sigma,vector<float> &lb,vector<float> &ub);void randGaussian(int i,float mean,float sigma,vector<float> &lb,vector<float> &ub);float distanceTo(const RealChromosome &g)const;RealChromosome &operator=(const RealChromosome &c);bool operator<(const RealChromosome &c)const;bool operator==(const RealChromosome &other)const;};
class FitnessFunction{public: virtual float eval(const RealChromosome &x)=0;virtual ~FitnessFunction(){};};
using namespace std;class Mutation{public: Mutation();Mutation(float mutationRate,float mutationPerc);virtual ~Mutation();virtual void mutate(RealChromosome &x,vector<float> &lb,vector<float> &ub)=0;void setMutationRate(float mutationRate);void setMutationPercentage(float mutationPerc);float getMutationRate();float getMutationPercentage();protected: float mMutationRate;float mMutationPerc;};class UniformMutation : public Mutation{public: UniformMutation();UniformMutation(float mutationRate,float mutationPerc);~UniformMutation();void mutate(RealChromosome &x,vector<float> &lb,vector<float> &ub);};class GaussianMutation : public Mutation{public: GaussianMutation();GaussianMutation(float mutationRate,float mutationPerc);~GaussianMutation();void mutate(RealChromosome &x,vector<float> &lb,vector<float> &ub);};
using namespace std;class Crossover{public: Crossover(size_t chromosomeSize): mChromosomeSize(chromosomeSize){}virtual ~Crossover(){}virtual void crossover(RealChromosome &a,RealChromosome &b,RealChromosome &offspring)=0;protected: size_t mChromosomeSize;};class UniformCrossover: public Crossover{public: UniformCrossover(size_t chromosomeSize);~UniformCrossover();void crossover(RealChromosome &a,RealChromosome &b,RealChromosome &offspring);};class LinearCrossover: public Crossover{public: LinearCrossover(size_t chromosomeSize);~LinearCrossover();void crossover(RealChromosome &a,RealChromosome &b,RealChromosome &offspring);};
using namespace std;class Selection{public: virtual ~Selection(){}virtual void select(vector<float> &fitnessValues,int &indexA,int &indexB)=0;};class RouletteWheelSelection : public Selection{public: RouletteWheelSelection(size_t populationSize);~RouletteWheelSelection();void normalize(vector<float> &fitnessValues);void select(vector<float> &fitnessValues,int &indexA,int &indexB);private:vector<float> mNormalizedFitness;float mMinFitnessValue;float mMaxFitnessValue;void selectStochasticAcceptance(int &indexA,int &indexB);};class TournamentSelection : public Selection{public: TournamentSelection(size_t populationSize);~TournamentSelection();void setTournamentSize(int tournamentSize);void setSelectionProbability(float selectionProbability);int probabilisticTournament();float getAverageSelectionPressure()const;void validateParameters()const;void select(vector<float> &fitnessValues,int &indexA,int &indexB);int tournament(vector<float> &fitnessValues);private: int mTournamentSize;size_t mPopulationSize;float mSelectionProbability;vector<int> mPopulationIndices;vector<float> mTournamentFitness;vector<int> mTournamentIndex;};
class RealGA{public: RealGA();virtual ~RealGA();void restart();void init(RealGAOptions &opt,FitnessFunction *func,bool keepState);void setFitnessFunction(FitnessFunction *f);void resetPopulation();void resetGaussianMutationPerc();float evalFitness(const RealChromosome &);RealChromosome getBestChromosome();int getGeneration();const vector<RealChromosome> &getPopulation()const;void checkPopulation();string populationToString();string populationToCSVString();void populationToCSV(const string &csvFilename);void popInitRandUniform();void popInitRandGaussian(float mean,float sigma);void popInitGaussianMutate(vector<float> &gene,float mutatioRate,float mutationPerc);void popInitSetChromosome(unsigned int index,RealChromosome &chromosome);void popInitSetPopulation(vector<RealChromosome> &population);void evaluatePopulationFitness();virtual void evolve();protected: vector<float> mLB;vector<float> mUB;vector<RealChromosome> mPopulation;vector<RealChromosome> mNewPopulation;RealGAOptions mOptions;FitnessFunction *mFitnessFcn;vector<float> mFitnessValues;Selection *mSelectionAlgorithm;Crossover *mCrossover;Mutation *mMutation;int mGeneration;float mGaussianMutationPerc;float mUniformMutationPerc;void fillFitnessValues(vector<RealChromosome> &population);};
 RealChromosome::RealChromosome(){fitness=std::numeric_limits<float>::max();}RealChromosome::RealChromosome(int n): RealChromosome(){if(n <=0){throw std::invalid_argument("Chromosome size must be positive");}gene.reserve(n);gene.resize(n);}RealChromosome::RealChromosome(const RealChromosome &c): gene(c.gene),fitness(c.fitness){}RealChromosome::~RealChromosome()=default;RealChromosome &RealChromosome::operator=(const RealChromosome &c){if(this !=&c){gene=c.gene;fitness=c.fitness;}return *this;}bool RealChromosome::operator<(const RealChromosome &c)const{return fitness < c.fitness;}bool RealChromosome::operator==(const RealChromosome &other)const{if(gene.size()!=other.gene.size()){return false;}constexpr float epsilon=std::numeric_limits<float>::epsilon();for(size_t i=0;i < gene.size();++i){if(std::abs(gene[i] - other.gene[i])> epsilon){return false;}}return true;}std::string RealChromosome::toString()const{if(gene.empty()){return "[]";}std::ostringstream os;os.precision(10);os << "[";for(size_t i=0;i < gene.size()- 1;++i){os << gene[i] << ",";}os << gene.back()<< "]";return os.str();}float RealChromosome::distanceTo(const RealChromosome &g)const{if(gene.size()!=g.gene.size()){throw std::invalid_argument("Chromosomes must have same size for distance calculation");}float sse=0.0f;for(size_t i=0;i < gene.size();++i){const float dx=gene[i] - g.gene[i];sse +=dx * dx;}return std::sqrt(sse);}void RealChromosome::randUniform(vector<float> &lb,vector<float> &ub){for(size_t i=0;i < gene.size();i++){gene[i]=Stat::randUniform(lb[i],ub[i]);}}void RealChromosome::randUniform(int i,vector<float> &lb,vector<float> &ub){gene[i]=Stat::randUniform(lb[i],ub[i]);}void RealChromosome::randGaussian(float mean,float sigma,vector<float> &lb,vector<float> &ub){for(size_t i=0;i < gene.size();i++){gene[i]=Stat::randGaussian(mean,sigma);if(gene[i] < lb[i])gene[i]=lb[i];if(gene[i] > ub[i])gene[i]=ub[i];}}void RealChromosome::randGaussian(int i,float mean,float sigma,vector<float> &lb,vector<float> &ub){gene[i]=Stat::randGaussian(mean,sigma);if(gene[i] < lb[i])gene[i]=lb[i];if(gene[i] > ub[i])gene[i]=ub[i];}
 
 LinearCrossover::LinearCrossover(size_t chromosomeSize): Crossover(chromosomeSize){}LinearCrossover::~LinearCrossover(){}void LinearCrossover::crossover(RealChromosome &a,RealChromosome &b,RealChromosome &offspring){REALGA_ERROR(offspring.gene.size()!=mChromosomeSize,"offspring.size()!=chromosomeSize");float alpha=Stat::randUniform();for(size_t j=0;j < mChromosomeSize;j++){offspring.gene[j]=alpha*a.gene[j] +(1.0f-alpha)*b.gene[j];}}
 UniformCrossover::UniformCrossover(size_t chromosomeSize): Crossover(chromosomeSize){}UniformCrossover::~UniformCrossover(){}void UniformCrossover::crossover(RealChromosome &a,RealChromosome &b,RealChromosome &offspring){for(size_t j=0;j < mChromosomeSize;j++){if(Stat::randUniform()< 0.5){offspring.gene[j]=a.gene[j];}else{offspring.gene[j]=b.gene[j];}}}
Mutation::Mutation(){mMutationRate=0.1;mMutationPerc=1.0;}Mutation::Mutation(float mutationRate,float mutationPerc){mMutationRate=mutationRate;mMutationPerc=mutationPerc;}Mutation::~Mutation(){}void Mutation::setMutationRate(float mutationRate){mMutationRate=mutationRate;}void Mutation::setMutationPercentage(float mutationPerc){mMutationPerc=mutationPerc;}float Mutation::getMutationRate(){return mMutationRate;}float Mutation::getMutationPercentage(){return mMutationPerc;}
 GaussianMutation::GaussianMutation(): Mutation(){}GaussianMutation::GaussianMutation(float mutationRate,float mutationPerc): Mutation(mutationRate,mutationPerc){}GaussianMutation::~GaussianMutation(){}void GaussianMutation::mutate(RealChromosome &x,vector<float> &lb,vector<float> &ub){for(size_t i=0;i < x.gene.size();i++){if(Stat::randUniform()< mMutationRate){float delta=ub[i] - lb[i];float sigma=mMutationPerc *(delta / 4.0f);float r=Stat::randGaussian(0.0,sigma);if(isnan(r)|| isinf(r)){r=0.0;}x.gene[i] +=r;if(x.gene[i] < lb[i])x.gene[i]=lb[i];if(x.gene[i] > ub[i])x.gene[i]=ub[i];}}}
 UniformMutation::UniformMutation(): Mutation(){}UniformMutation::UniformMutation(float mutationRate,float mutationPerc): Mutation(mutationRate,mutationPerc){}UniformMutation::~UniformMutation(){}void UniformMutation::mutate(RealChromosome &x,vector<float> &lb,vector<float> &ub){for(size_t i=0;i < x.gene.size();i++){if(Stat::randUniform()< mMutationRate){float fraction=mMutationPerc *(Stat::randUniform()- 0.5)*(ub[i] - lb[i]);x.gene[i] +=fraction;if(x.gene[i] < lb[i])x.gene[i]=lb[i];if(x.gene[i] > ub[i])x.gene[i]=ub[i];}}}
 RealGAOptions::RealGAOptions(){populationSize=100;chromosomeSize=-1;verbose=NO_VERBOSE;seed=42;elitismFactor=0.1;mutateDuplicatedFitness=false;selectionType=ROULETTE_WHEEL_SELECTION;selectionTournamentSize=16;selectionTournamentProbability=0.85;crossoverType=UNIFORM_CROSSOVER;crossoverindexA=-1;mutationType=UNIFORM_MUTATION;mutationRate=0.1;mutationUniformPercDelta=0.01;mutationUniformPercMin=0.001;mutationGaussianPercDelta=0.01;mutationGaussianPercMin=0.001;}RealGAOptions::~RealGAOptions(){}void RealGAOptions::setPopulationSize(size_t value){REALGA_ERROR(value <=0,"Population size must be > 0");populationSize=value;}void RealGAOptions::setChromosomeSize(size_t value){REALGA_ERROR(value <=0,"Chromosome size must be > 0");chromosomeSize=value;}void RealGAOptions::setLowerBounds(const vector<float> &lb){lowerBounds=lb;}void RealGAOptions::setUpperBounds(const vector<float> &ub){upperBounds=ub;}void RealGAOptions::setBounds(const vector<float> &lb,const vector<float> &ub){setLowerBounds(lb);setUpperBounds(ub);}void RealGAOptions::setVerbose(int level){if(level <=0)verbose=NO_VERBOSE;else if(level==1)verbose=SOFT_VERBOSE;else if(level >=2)verbose=HARD_VERBOSE;}void RealGAOptions::setElitismFactor(float value){REALGA_ERROR((value < 0.0)||(value > 1.0),"elitism factor must be in [0,1]");elitismFactor=value;}void RealGAOptions::setMutateDuplicatedFitness(bool value){mutateDuplicatedFitness=value;}void RealGAOptions::setSeed(unsigned int value){seed=value;}void RealGAOptions::setSelectionType(string value){if(value=="roulette")selectionType=ROULETTE_WHEEL_SELECTION;else if(value=="tournament")selectionType=TOURNAMENT_SELECTION;else REALGA_ERROR(1,value << " is an invalid selection type");}void RealGAOptions::setSelectionTournamentSize(int value){REALGA_ERROR(value <=0,"Tournament size must be > 0");selectionTournamentSize=value;}void RealGAOptions::setSelectionTournamentProbability(float value){REALGA_ERROR((value < 0.0)||(value > 1.0),"tournament probability must be in [0,1]");selectionTournamentProbability=value;}void RealGAOptions::setMutationType(string value){if(value=="uniform")mutationType=UNIFORM_MUTATION;else if(value=="gaussian")mutationType=GAUSSIAN_MUTATION;else REALGA_ERROR(1,value << " is an invalid mutation type");}void RealGAOptions::setMutationRate(float value){REALGA_ERROR((value < 0.0)||(value > 1.0),"mutation rate must be in [0,1]");mutationRate=value;}void RealGAOptions::setMutationUniformPerc(float percDelta,float percMin){REALGA_ERROR((percDelta < 0.0)||(percDelta > 1.0),"uniform mutation delta percentage must be in [0,1]");REALGA_ERROR((percMin < 0.0)||(percMin > 1.0),"uniform mutation min percentage must be in [0,1]");mutationUniformPercDelta=percDelta;mutationUniformPercMin=percMin;}void RealGAOptions::setMutationGaussianPerc(float percDelta,float percMin){REALGA_ERROR((percDelta < 0.0)||(percDelta > 1.0),"gaussian mutation delta percentage must be in [0,1]");REALGA_ERROR((percMin < 0.0)||(percMin > 1.0),"gaussian mutation min percentage must be in [0,1]");mutationGaussianPercDelta=percDelta;mutationGaussianPercMin=percMin;}void RealGAOptions::setCrossoverType(string value){if(value=="uniform")crossoverType=UNIFORM_CROSSOVER;else if(value=="linear")crossoverType=LINEAR_CROSSOVER;else REALGA_ERROR(1,value << " is an invalid crossover type");}void RealGAOptions::setSinglePointCrossoverIndex(int value){crossoverindexA=value;}void RealGAOptions::checkOptions(){REALGA_ERROR((lowerBounds.size()!=chromosomeSize),"lower bounds size " << lowerBounds.size()<< " must equals chromosome size " << chromosomeSize);REALGA_ERROR((upperBounds.size()!=chromosomeSize),"upper bounds size " << upperBounds.size()<< " must equals chromosome size " << chromosomeSize);if(selectionType==TOURNAMENT_SELECTION){REALGA_ERROR(populationSize < selectionTournamentSize,"tournament size " << selectionTournamentSize << " must be less than population size " << populationSize);}}
 RealGA::RealGA(){mFitnessFcn=nullptr;mGeneration=0;mSelectionAlgorithm=nullptr;mCrossover=nullptr;mMutation=nullptr;mGaussianMutationPerc=1.0f;mUniformMutationPerc=1.0f;}RealGA::~RealGA(){if(mCrossover !=nullptr){delete mCrossover;mCrossover=nullptr;}if(mSelectionAlgorithm !=nullptr){delete mSelectionAlgorithm;mSelectionAlgorithm=nullptr;}if(mMutation !=nullptr){delete mMutation;mMutation=nullptr;}}void RealGA::resetPopulation(){if(mOptions.populationSize !=mPopulation.size()){mPopulation.resize(mOptions.populationSize,mOptions.chromosomeSize);mNewPopulation.resize(mOptions.populationSize,mOptions.chromosomeSize);mFitnessValues.resize(mOptions.populationSize);}if(mPopulation.size()!=0){if(mOptions.chromosomeSize !=mPopulation[0].gene.size()){mPopulation.resize(mOptions.populationSize,mOptions.chromosomeSize);mNewPopulation.resize(mOptions.populationSize,mOptions.chromosomeSize);mFitnessValues.resize(mOptions.populationSize);}}}void RealGA::resetGaussianMutationPerc(){mGaussianMutationPerc=1.0f;mUniformMutationPerc=1.0f;}void RealGA::restart(){if(mOptions.mutationType==GAUSSIAN_MUTATION){resetGaussianMutationPerc();}mGeneration=0;}void RealGA::init(RealGAOptions &opt,FitnessFunction *func,bool keepState){mOptions=opt;mFitnessFcn=func;if(mSelectionAlgorithm){delete mSelectionAlgorithm;mSelectionAlgorithm=nullptr;}if(mCrossover){delete mCrossover;mCrossover=nullptr;}if(mMutation){delete mMutation;mMutation=nullptr;}if(keepState){REALGA_ERROR(mPopulation.empty(),"reset is false,but chromosome population size is 0");REALGA_ERROR(mOptions.populationSize !=mPopulation.size(),"reset is false,but population size " << mPopulation.size()<< " is different from option population size " << mOptions.populationSize);REALGA_ERROR(mOptions.chromosomeSize !=mPopulation[0].gene.size(),"reset is false,but chromosome size " << mPopulation[0].gene.size()<< " is different from option chromosome size " << mOptions.chromosomeSize);}else{resetPopulation();if(mOptions.mutationType==GAUSSIAN_MUTATION){resetGaussianMutationPerc();}switch(mOptions.selectionType){case ROULETTE_WHEEL_SELECTION: mSelectionAlgorithm=new RouletteWheelSelection(mOptions.populationSize);break;case TOURNAMENT_SELECTION: mSelectionAlgorithm=new TournamentSelection(mOptions.populationSize);((TournamentSelection *)mSelectionAlgorithm)->setTournamentSize(mOptions.selectionTournamentSize);((TournamentSelection *)mSelectionAlgorithm)->setSelectionProbability(mOptions.selectionTournamentProbability);break;}REALGA_ERROR(mSelectionAlgorithm==nullptr,"SelectionAlgorithm is null");switch(mOptions.crossoverType){case UNIFORM_CROSSOVER: mCrossover=new UniformCrossover(mOptions.chromosomeSize);break;case LINEAR_CROSSOVER: mCrossover=new LinearCrossover(mOptions.chromosomeSize);break;}REALGA_ERROR(mCrossover==nullptr,"Crossover is null");switch(mOptions.mutationType){case UNIFORM_MUTATION: mMutation=new UniformMutation(mOptions.mutationRate,mUniformMutationPerc);break;case GAUSSIAN_MUTATION: mMutation=new GaussianMutation(mOptions.mutationRate,mGaussianMutationPerc);break;}Stat::setSeed(mOptions.seed);mGeneration=0;mOptions.checkOptions();mLB=mOptions.lowerBounds;mUB=mOptions.upperBounds;}}void RealGA::setFitnessFunction(FitnessFunction *f){mFitnessFcn=f;}void RealGA::fillFitnessValues(vector<RealChromosome> &population){for(size_t i=0;i < population.size();i++){mFitnessValues[i]=population[i].fitness;}}int RealGA::getGeneration(){return mGeneration;}float RealGA::evalFitness(const RealChromosome &x){float eval=mFitnessFcn->eval(x);if(isnan(eval)|| isinf(eval)){return MAXFLOAT;}return eval;}RealChromosome RealGA::getBestChromosome(){int minIndex=0;float minValue=mPopulation[0].fitness;for(size_t i=1;i < mPopulation.size();i++){float value=mPopulation[i].fitness;if(value < minValue){minValue=value;minIndex=i;}}return mPopulation[minIndex];}const vector<RealChromosome> &RealGA::getPopulation()const{return mPopulation;}string RealGA::populationToString(){std::ostringstream os;os << "Population of Generation: " << mGeneration << "\n";for(size_t i=0;i < mOptions.populationSize;i++){os << i << ": " << mPopulation[i].toString()<< " -> Fitness " << mPopulation[i].fitness << "\n";}return os.str();}string RealGA::populationToCSVString(){std::ostringstream os;os << "id,";for(size_t i=0;i < mPopulation[i].gene.size();i++){os << "x" << i << ",";}os << "fitness\n";for(size_t i=0;i < mOptions.populationSize;i++){string geneString=mPopulation[i].toString();os << i << "," << geneString.substr(1,geneString.size()- 2)<< "," << mPopulation[i].fitness << "\n";}return os.str();}void RealGA::populationToCSV(const std::string &csvFilename){std::ofstream ofs(csvFilename);if(!ofs.is_open()){std::cerr << "Error: Could not open file " << csvFilename << " for writing." << std::endl;return;}ofs << populationToCSVString();ofs.close();}void RealGA::checkPopulation(){for(size_t i=0;i < mOptions.populationSize;i++){for(size_t j=0;j < mOptions.chromosomeSize;++j){REALGA_ERROR(isnan(mPopulation[i].gene[j])|| isinf(mPopulation[i].gene[j]),"error in chromosome " << i << " " << mPopulation[i].toString());}}}void RealGA::evolve(){int n=mOptions.populationSize;int elitismNumber=(int)(mOptions.elitismFactor * n);std::nth_element(mPopulation.begin(),mPopulation.begin()+ elitismNumber,mPopulation.end(),[](const RealChromosome& a,const RealChromosome& b){return a.fitness < b.fitness;});std::unordered_set<float> fitnessRegistry;int newPopIdx=0;for(;newPopIdx < elitismNumber;++newPopIdx){mNewPopulation[newPopIdx]=mPopulation[newPopIdx];if(mOptions.mutateDuplicatedFitness){fitnessRegistry.insert(mNewPopulation[newPopIdx].fitness);}}RealChromosome offspring(mOptions.chromosomeSize);while(newPopIdx < n){int idxA,idxB;mSelectionAlgorithm->select(mFitnessValues,idxA,idxB);mCrossover->crossover(mPopulation[idxA],mPopulation[idxB],offspring);mMutation->mutate(offspring,mLB,mUB);offspring.fitness=evalFitness(offspring);if(mOptions.mutateDuplicatedFitness){int attempts=0;while(fitnessRegistry.find(offspring.fitness)!=fitnessRegistry.end()&& attempts < 10){mMutation->mutate(offspring,mLB,mUB);offspring.fitness=evalFitness(offspring);attempts++;}fitnessRegistry.insert(offspring.fitness);}mNewPopulation[newPopIdx]=offspring;newPopIdx++;}if(mOptions.mutationType==GAUSSIAN_MUTATION){mGaussianMutationPerc=fmax(mOptions.mutationGaussianPercMin,1.0f - mOptions.mutationGaussianPercDelta *(float)mGeneration);mMutation->setMutationPercentage(mGaussianMutationPerc);}if(mOptions.mutationType==UNIFORM_MUTATION){mUniformMutationPerc=fmax(mOptions.mutationUniformPercMin,1.0f - mOptions.mutationUniformPercDelta *(float)mGeneration);mMutation->setMutationPercentage(mUniformMutationPerc);}mPopulation=mNewPopulation;fillFitnessValues(mPopulation);mGeneration++;}void RealGA::popInitRandUniform(){for(size_t i=0;i < mOptions.populationSize;i++){mPopulation[i].randUniform(mLB,mUB);mPopulation[i].fitness=evalFitness(mPopulation[i]);}fillFitnessValues(mPopulation);}void RealGA::popInitRandGaussian(float mean,float sigma){for(size_t i=0;i < mOptions.populationSize;i++){mPopulation[i].randGaussian(mean,sigma,mLB,mUB);mPopulation[i].fitness=evalFitness(mPopulation[i]);}fillFitnessValues(mPopulation);}void RealGA::popInitGaussianMutate(vector<float> &gene,float mutatioRate,float mutationPerc){RealChromosome g(mOptions.chromosomeSize);GaussianMutation mutation(mutatioRate,mutationPerc);for(size_t i=0;i < mOptions.chromosomeSize;i++){g.gene[i]=gene[i];}mPopulation[0]=g;mPopulation[0].fitness=evalFitness(mPopulation[0]);for(size_t i=1;i < mOptions.populationSize;i++){mPopulation[i]=g;mutation.mutate(mPopulation[i],mLB,mUB);mPopulation[i].fitness=evalFitness(mPopulation[i]);}fillFitnessValues(mPopulation);}void RealGA::popInitSetChromosome(unsigned int index,RealChromosome &chromosome){REALGA_ERROR(index >=mOptions.populationSize,"index " << index << " is out of range [0," << mOptions.populationSize << ")");for(size_t i=0;i < chromosome.gene.size();i++)REALGA_ERROR(chromosome.gene[i] < mLB[i] || chromosome.gene[i] > mUB[i],"chromosome " << chromosome.toString()<< " gene " << i << " is " << chromosome.gene[i]);mPopulation[index]=chromosome;mPopulation[index].fitness=evalFitness(mPopulation[index]);}void RealGA::popInitSetPopulation(vector<RealChromosome> &population){REALGA_ERROR(mPopulation.size()!=mOptions.populationSize,"size of population " << mPopulation.size()<< " is not the same as Np=" << mOptions.populationSize);mPopulation=population;}void RealGA::evaluatePopulationFitness(){for(size_t i=0;i < mOptions.populationSize;i++){mPopulation[i].fitness=evalFitness(mPopulation[i]);}}
 RouletteWheelSelection::RouletteWheelSelection(size_t populationSize){mNormalizedFitness.resize(populationSize);}RouletteWheelSelection::~RouletteWheelSelection(){}void RouletteWheelSelection::normalize(vector<float> &fitnessValues){auto mm=std::minmax_element(fitnessValues.begin(),fitnessValues.end());mMinFitnessValue=*mm.first;mMaxFitnessValue=*mm.second;for(size_t i=0;i < fitnessValues.size();i++){if(mMaxFitnessValue==mMinFitnessValue){mNormalizedFitness[i]=1.0f;}else{mNormalizedFitness[i]=(1.01f -(fitnessValues[i] - mMinFitnessValue)/(mMaxFitnessValue - mMinFitnessValue))/ 1.01f;}}}void RouletteWheelSelection::selectStochasticAcceptance(int &indexA,int &indexB){int n=mNormalizedFitness.size();while(1){indexA=Stat::randIndex(n);if(Stat::randUniform()< mNormalizedFitness[indexA]){break;}}while(1){indexB=Stat::randIndex(n);if(indexB==indexA)continue;if(Stat::randUniform()< mNormalizedFitness[indexB]){break;}}}void RouletteWheelSelection::select(vector<float> &fitnessValues,int &indexA,int &indexB){normalize(fitnessValues);selectStochasticAcceptance(indexA,indexB);}
 TournamentSelection::TournamentSelection(size_t populationSize){mTournamentSize=std::max(2,(int)((float)populationSize * 0.1f));mPopulationSize=populationSize;mSelectionProbability=0.85f;mTournamentFitness.resize(mTournamentSize);mTournamentIndex.resize(mTournamentSize);}TournamentSelection::~TournamentSelection()=default;void TournamentSelection::setTournamentSize(int tournamentSize){mTournamentSize=tournamentSize;mTournamentFitness.resize(mTournamentSize);mTournamentIndex.resize(mTournamentSize);}void TournamentSelection::setSelectionProbability(float selectionProbability){mSelectionProbability=selectionProbability;}void TournamentSelection::select(std::vector<float> &fitnessValues,int &indexA,int &indexB){indexA=tournament(fitnessValues);indexB=tournament(fitnessValues);while(indexA==indexB){indexA=tournament(fitnessValues);indexB=tournament(fitnessValues);}}int TournamentSelection::tournament(std::vector<float> &fitnessValues){int i=0;while(i < mTournamentSize){int index=Stat::randIndex(mPopulationSize);bool match=false;for(int j=0;j < i;j++){if(mTournamentIndex[j]==index){match=true;break;}}if(!match){mTournamentIndex[i]=index;mTournamentFitness[i]=fitnessValues[index];++i;}}int kth,localKthIndex,kthMinIndex;if(mSelectionProbability < 1.0f){float chooseP=mSelectionProbability;for(kth=1;kth < mTournamentSize;++kth){if(Stat::randUniform()< chooseP)break;chooseP *=(1.0f - mSelectionProbability);}static std::vector<int> order;order.resize(mTournamentSize);std::iota(order.begin(),order.end(),0);int kthPos=std::clamp(kth - 1,0,mTournamentSize - 1);std::nth_element(order.begin(),order.begin()+ kthPos,order.end(),[&](int a,int b){return mTournamentFitness[a] < mTournamentFitness[b];});localKthIndex=order[kthPos];kthMinIndex=mTournamentIndex[localKthIndex];}else{auto it=std::min_element(mTournamentFitness.begin(),mTournamentFitness.begin()+ mTournamentSize);localKthIndex=static_cast<int>(std::distance(mTournamentFitness.begin(),it));kthMinIndex=mTournamentIndex[localKthIndex];}return kthMinIndex;}
 namespace{thread_local std::mt19937 generator(std::random_device{}());thread_local std::uniform_real_distribution<float> uniform_dist(0.0f,1.0f);thread_local std::normal_distribution<float> normal_dist(0.0f,1.0f);constexpr float MIN_SIGMA=1e-6f;}float Stat::randUniform(){return uniform_dist(generator);}float Stat::randUniform(float lb,float ub){if(lb >=ub){throw std::invalid_argument("lb >=ub");}std::uniform_real_distribution<float> dist(lb,ub);return dist(generator);}int Stat::randIndex(int n){if(n <=0){throw std::invalid_argument("n <=0");}std::uniform_int_distribution<int> dist(0,n - 1);return dist(generator);}float Stat::randGaussian(float mean,float sigma){if(sigma < MIN_SIGMA){sigma=MIN_SIGMA;}normal_dist.param(std::normal_distribution<float>::param_type(mean,sigma));return normal_dist(generator);}void Stat::setSeed(unsigned int seed){generator.seed(seed);uniform_dist.reset();normal_dist.reset();}void Stat::setSeedFromDevice(){generator.seed(std::random_device{}());uniform_dist.reset();normal_dist.reset();}int Stat::randInteger(int min_val,int max_val){if(min_val >=max_val){throw std::invalid_argument("min_val >=max_val");}std::uniform_int_distribution<int> dist(min_val,max_val);return dist(generator);}

