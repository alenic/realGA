//Original chars:  44451
//Minified chars:  27961
//minified/original:  62.90%
#define REALGA_ERROR(condition,msg_expr)\
#define DEBUG(msg)\
#include<string>
#include<random>
#include<cmath>
#include<fstream>
#include<stdlib.h>
#include<math.h>
#include<stdexcept>
#include<stdio.h>
#include<algorithm>
#include<iostream>
#include<limits>
#include<thread>
#include<numeric>
#include<sstream>
#include<cstddef>//forsize_t
#include<vector>
#pragma onceclass RealGAException : public std::runtime_error{public: RealGAException(const std::string &msg): std::runtime_error(msg){}};if(condition)\{\ std::ostringstream oss;\ oss << msg_expr;\ throw RealGAException(std::string(__func__)+ ": " + oss.str()+ "(" + __FILE__ + ":" + std::to_string(__LINE__)+ ")");\}{\ cout << "DEBUG: " << msg << endl;\}
namespace Stat{float randUniform();float randUniform(float lb,float ub);int randIndex(int n);float randGaussian(float mean,float sigma);void setSeed(unsigned int seed);void setSeedFromDevice();int randInteger(int min_val,int max_val);};
using namespace std;namespace RALG{int partition(std::vector<float> &arr,int l,int r);float kthSmallest(const std::vector<float> &arr,int l,int r,int k);int argKthSmallest(const std::vector<float> &arr,int l,int r,int k);int searchIndexBinarySearch(const vector<float> &arr,float x,int left,int right);void minmax(const vector<float> &arr,float &minValue,float &maxValue);int argMin(const float arr[],int l,int r);}
using namespace std;typedef enum{ROULETTE_WHEEL_SELECTION=1,TOURNAMENT_SELECTION}SelectionType;typedef enum{UNIFORM_CROSSOVER=1}CrossoverType;typedef enum{UNIFORM_MUTATION=1,GAUSSIAN_MUTATION}MutationType;typedef enum{NO_VERBOSE=0,SOFT_VERBOSE=1,HARD_VERBOSE=2}VerboseType;class RealGAOptions{public: RealGAOptions();~RealGAOptions();void setPopulationSize(size_t np);void setChromosomeSize(size_t nx);void setLowerBounds(const vector<float> &lb);void setUpperBounds(const vector<float> &ub);void setBounds(const vector<float> &lb,const vector<float> &ub);void setVerbose(string value);void setSeed(unsigned int seedValue);void setElitismFactor(float value);void setMutateDuplicatedFitness(bool value);void setSelectionType(string value);void setSelectionTournamentSize(int value);void setSelectionTournamentProbability(float value);void setMutationType(string value);void setMutationRate(float value);void setMutationGaussianPerc(float percDelta,float percMin);void setMutationUniformPerc(float percDelta,float percMin);void setCrossoverType(string value);void setSinglePointCrossoverIndex(int value);void checkOptions();size_t populationSize;size_t chromosomeSize;vector<float> lowerBounds;vector<float> upperBounds;int seed;VerboseType verbose;float elitismFactor;bool mutateDuplicatedFitness;SelectionType selectionType;size_t selectionTournamentSize;float selectionTournamentProbability;CrossoverType crossoverType;int crossoverindexA;MutationType mutationType;float mutationRate;float mutationUniformPercDelta;float mutationUniformPercMin;float mutationGaussianPercDelta;float mutationGaussianPercMin;};
using namespace std;class RealChromosome{public: vector<float> gene;float fitness;RealChromosome();RealChromosome(int n);RealChromosome(const RealChromosome &c);~RealChromosome();string toString()const;void randUniform(vector<float> &lb,vector<float> &ub);void randUniform(int i,vector<float> &lb,vector<float> &ub);void randGaussian(float mean,float sigma,vector<float> &lb,vector<float> &ub);void randGaussian(int i,float mean,float sigma,vector<float> &lb,vector<float> &ub);float distanceTo(const RealChromosome &g)const;RealChromosome &operator=(const RealChromosome &c);bool operator<(const RealChromosome &c)const;bool operator==(const RealChromosome &other)const;};
class FitnessFunction{public: virtual float eval(const RealChromosome &x)=0;virtual ~FitnessFunction(){};};
using namespace std;class Selection{public: virtual ~Selection(){}virtual void select(vector<float> &fitnessValues,int &indexA,int &indexB)=0;};class RouletteWheelSelection : public Selection{public: RouletteWheelSelection(size_t populationSize);~RouletteWheelSelection();void normalize(vector<float> &fitnessValues);void select(vector<float> &fitnessValues,int &indexA,int &indexB);private:vector<float> mNormalizedFitness;float mMinFitnessValue;float mMaxFitnessValue;void selectStochasticAcceptance(int &indexA,int &indexB);};class TournamentSelection : public Selection{public: TournamentSelection(size_t populationSize);~TournamentSelection();void setTournamentSize(int tournamentSize);void setSelectionProbability(float selectionProbability);int probabilisticTournament();float getAverageSelectionPressure()const;void validateParameters()const;void select(vector<float> &fitnessValues,int &indexA,int &indexB);int tournament(vector<float> &fitnessValues);private: int mTournamentSize;size_t mPopulationSize;float mSelectionProbability;vector<int> mPopulationIndices;vector<float> mTournamentFitness;vector<int> mTournamentIndex;};
class RealGA{public: RealGA();virtual ~RealGA();void restart();void init(RealGAOptions &opt,FitnessFunction *func,bool keepState);void setFitnessFunction(FitnessFunction *f);void resetPopulation();void resetGaussianMutationPerc();float evalFitness(const RealChromosome &);RealChromosome getBestChromosome();int getGeneration();const vector<RealChromosome> &getPopulation()const;void checkPopulation();string populationToString();string populationToCSVString();void populationToCSV(const string &csvFilename);void popInitRandUniform();void popInitRandGaussian(float mean,float sigma);void popInitGaussianMutate(vector<float> &gene,float mutatioRate,float mutationPerc);void popInitSetChromosome(unsigned int index,RealChromosome &chromosome);void popInitSetPopulation(vector<RealChromosome> &population);void evaluatePopulationFitness();virtual void evolve();protected: vector<float> mLB;vector<float> mUB;vector<RealChromosome> mPopulation;vector<RealChromosome> mNewPopulation;RealGAOptions mOptions;FitnessFunction *mFitnessFcn;vector<float> mFitnessValues;Selection *mSelectionAlgorithm;Crossover *mCrossover;Mutation *mMutation;int mGeneration;float mGaussianMutationPerc;float mUniformMutationPerc;void fillFitnessValues(vector<RealChromosome> &population);};
 namespace{thread_local std::mt19937 generator(std::random_device{}());thread_local std::uniform_real_distribution<float> uniform_dist(0.0f,1.0f);thread_local std::normal_distribution<float> normal_dist(0.0f,1.0f);constexpr float MIN_SIGMA=1e-6f;}float Stat::randUniform(){return uniform_dist(generator);}float Stat::randUniform(float lb,float ub){if(lb >=ub){throw std::invalid_argument("lb >=ub");}std::uniform_real_distribution<float> dist(lb,ub);return dist(generator);}int Stat::randIndex(int n){if(n <=0){throw std::invalid_argument("n <=0");}std::uniform_int_distribution<int> dist(0,n - 1);return dist(generator);}float Stat::randGaussian(float mean,float sigma){if(sigma < MIN_SIGMA){sigma=MIN_SIGMA;}normal_dist.param(std::normal_distribution<float>::param_type(mean,sigma));return normal_dist(generator);}void Stat::setSeed(unsigned int seed){generator.seed(seed);uniform_dist.reset();normal_dist.reset();}void Stat::setSeedFromDevice(){generator.seed(std::random_device{}());uniform_dist.reset();normal_dist.reset();}int Stat::randInteger(int min_val,int max_val){if(min_val >=max_val){throw std::invalid_argument("min_val >=max_val");}std::uniform_int_distribution<int> dist(min_val,max_val);return dist(generator);}
 namespace RALG{namespace{constexpr float FLOAT_EPSILON=std::numeric_limits<float>::epsilon();constexpr int INVALID_INDEX=-1;}int partition(std::vector<float> &arr,int l,int r){if(l >=r || arr.empty()){throw std::invalid_argument("Invalid partition bounds");}float x=arr[r];int i=l;for(int j=l;j <=r - 1;j++){if(arr[j] <=x){std::swap(arr[i],arr[j]);i++;}}std::swap(arr[i],arr[r]);return i;}float kthSmallest(const std::vector<float> &arr,int l,int r,int k){if(arr.empty()){throw std::invalid_argument("Array cannot be empty");}if(l < 0 || r >=static_cast<int>(arr.size())|| l > r){throw std::out_of_range("Invalid array bounds");}if(k <=0 || k > r - l + 1){throw std::out_of_range("k is out of valid range");}std::vector<float> copy(arr.begin()+ l,arr.begin()+ r + 1);std::nth_element(copy.begin(),copy.begin()+ k - 1,copy.end());return copy[k - 1];}int argKthSmallest(const std::vector<float> &arr,int l,int r,int k){if(arr.empty()){throw std::invalid_argument("Array cannot be empty");}if(l < 0 || r >=static_cast<int>(arr.size())|| l > r){throw std::out_of_range("Invalid array bounds");}if(k <=0 || k > r - l + 1){throw std::out_of_range("k is out of valid range");}std::vector<std::pair<float,int>> indexed_values;indexed_values.reserve(r - l + 1);for(int i=l;i <=r;++i){indexed_values.emplace_back(arr[i],i);}std::nth_element(indexed_values.begin(),indexed_values.begin()+ k - 1,indexed_values.end());return indexed_values[k - 1].second;}int searchIndexBinarySearch(const std::vector<float> &arr,float x,int left,int right){if(arr.empty()){return INVALID_INDEX;}if(left < 0 || right >=static_cast<int>(arr.size())|| left > right){return INVALID_INDEX;}#ifdef DEBUG if(!std::is_sorted(arr.begin()+ left,arr.begin()+ right + 1)){throw std::logic_error("Array must be sorted for binary search");}while(left <=right){int mid=left +(right - left)/ 2;if(std::abs(arr[mid] - x)< FLOAT_EPSILON){return mid;}else if(arr[mid] < x){left=mid + 1;}else{right=mid - 1;}}return INVALID_INDEX;}void minmax(const std::vector<float> &arr,float &minValue,float &maxValue){if(arr.empty()){throw std::invalid_argument("Array cannot be empty");}auto result=std::minmax_element(arr.begin(),arr.end());minValue=*result.first;maxValue=*result.second;}int argMin(const float arr[],int l,int r){if(arr==nullptr){throw std::invalid_argument("Array pointer cannot be null");}if(l > r){throw std::invalid_argument("Invalid array bounds");}const float *minPtr=std::min_element(arr + l,arr + r + 1);return static_cast<int>(minPtr - arr);}int argMax(const std::vector<float> &arr){if(arr.empty()){throw std::invalid_argument("Array cannot be empty");}auto maxIt=std::max_element(arr.begin(),arr.end());return static_cast<int>(std::distance(arr.begin(),maxIt));}int argMin(const std::vector<float> &arr){if(arr.empty()){throw std::invalid_argument("Array cannot be empty");}auto minIt=std::min_element(arr.begin(),arr.end());return static_cast<int>(std::distance(arr.begin(),minIt));}void partialSort(std::vector<float> &arr,int k){if(arr.empty()){throw std::invalid_argument("Array cannot be empty");}if(k <=0 || k > static_cast<int>(arr.size())){throw std::out_of_range("k is out of valid range");}std::partial_sort(arr.begin(),arr.begin()+ k,arr.end());}std::vector<int> argKSmallest(const std::vector<float> &arr,int k){if(arr.empty()){throw std::invalid_argument("Array cannot be empty");}if(k <=0 || k > static_cast<int>(arr.size())){throw std::out_of_range("k is out of valid range");}std::vector<int> indices(arr.size());std::iota(indices.begin(),indices.end(),0);std::partial_sort(indices.begin(),indices.begin()+ k,indices.end(),[&arr](int i,int j){return arr[i] < arr[j];});indices.resize(k);return indices;}}
 RealGAOptions::RealGAOptions(){populationSize=100;chromosomeSize=-1;verbose=NO_VERBOSE;seed=42;elitismFactor=0.1;mutateDuplicatedFitness=false;selectionType=ROULETTE_WHEEL_SELECTION;selectionTournamentSize=16;selectionTournamentProbability=0.85;crossoverType=UNIFORM_CROSSOVER;crossoverindexA=-1;mutationType=UNIFORM_MUTATION;mutationRate=0.1;mutationUniformPercDelta=0.01;mutationUniformPercMin=0.001;mutationGaussianPercDelta=0.01;mutationGaussianPercMin=0.001;}RealGAOptions::~RealGAOptions(){}void RealGAOptions::setPopulationSize(size_t value){REALGA_ERROR(value <=0,"Population size must be > 0");populationSize=value;}void RealGAOptions::setChromosomeSize(size_t value){REALGA_ERROR(value <=0,"Chromosome size must be > 0");chromosomeSize=value;}void RealGAOptions::setLowerBounds(const vector<float> &lb){lowerBounds=lb;}void RealGAOptions::setUpperBounds(const vector<float> &ub){upperBounds=ub;}void RealGAOptions::setBounds(const vector<float> &lb,const vector<float> &ub){setLowerBounds(lb);setUpperBounds(ub);}void RealGAOptions::setVerbose(string value){if(value=="none")verbose=NO_VERBOSE;else if(value=="soft")verbose=SOFT_VERBOSE;else if(value=="hard")verbose=HARD_VERBOSE;else REALGA_ERROR(1,value << " is an invalid verbose type");}void RealGAOptions::setElitismFactor(float value){REALGA_ERROR((value < 0.0)||(value > 1.0),"elitism factor must be in [0,1]");elitismFactor=value;}void RealGAOptions::setMutateDuplicatedFitness(bool value){mutateDuplicatedFitness=value;}void RealGAOptions::setSeed(unsigned int value){seed=value;}void RealGAOptions::setSelectionType(string value){if(value=="roulette")selectionType=ROULETTE_WHEEL_SELECTION;else if(value=="tournament")selectionType=TOURNAMENT_SELECTION;else REALGA_ERROR(1,value << " is an invalid selection type");}void RealGAOptions::setSelectionTournamentSize(int value){REALGA_ERROR(value <=0,"Tournament size must be > 0");selectionTournamentSize=value;}void RealGAOptions::setSelectionTournamentProbability(float value){REALGA_ERROR((value < 0.0)||(value > 1.0),"tournament probability must be in [0,1]");selectionTournamentProbability=value;}void RealGAOptions::setMutationType(string value){if(value=="uniform")mutationType=UNIFORM_MUTATION;else if(value=="gaussian")mutationType=GAUSSIAN_MUTATION;else REALGA_ERROR(1,value << " is an invalid mutation type");}void RealGAOptions::setMutationRate(float value){REALGA_ERROR((value < 0.0)||(value > 1.0),"mutation rate must be in [0,1]");mutationRate=value;}void RealGAOptions::setMutationUniformPerc(float percDelta,float percMin){REALGA_ERROR((percDelta < 0.0)||(percDelta > 1.0),"uniform mutation delta percentage must be in [0,1]");REALGA_ERROR((percMin < 0.0)||(percMin > 1.0),"uniform mutation min percentage must be in [0,1]");mutationUniformPercDelta=percDelta;mutationUniformPercMin=percMin;}void RealGAOptions::setMutationGaussianPerc(float percDelta,float percMin){REALGA_ERROR((percDelta < 0.0)||(percDelta > 1.0),"gaussian mutation delta percentage must be in [0,1]");REALGA_ERROR((percMin < 0.0)||(percMin > 1.0),"gaussian mutation min percentage must be in [0,1]");mutationGaussianPercDelta=percDelta;mutationGaussianPercMin=percMin;}void RealGAOptions::setCrossoverType(string value){if(value=="uniform")crossoverType=UNIFORM_CROSSOVER;else REALGA_ERROR(1,value << " is an invalid crossover type");}void RealGAOptions::setSinglePointCrossoverIndex(int value){crossoverindexA=value;}void RealGAOptions::checkOptions(){REALGA_ERROR((lowerBounds.size()!=chromosomeSize),"lower bounds size " << lowerBounds.size()<< " must equals chromosome size " << chromosomeSize);REALGA_ERROR((upperBounds.size()!=chromosomeSize),"upper bounds size " << upperBounds.size()<< " must equals chromosome size " << chromosomeSize);if(selectionType==TOURNAMENT_SELECTION){REALGA_ERROR(populationSize <=selectionTournamentSize,"tournament size " << selectionTournamentSize << " must be less than population size " << populationSize);}}
 RealChromosome::RealChromosome(){fitness=std::numeric_limits<float>::max();}RealChromosome::RealChromosome(int n): RealChromosome(){if(n <=0){throw std::invalid_argument("Chromosome size must be positive");}gene.reserve(n);gene.resize(n);}RealChromosome::RealChromosome(const RealChromosome &c): gene(c.gene),fitness(c.fitness){}RealChromosome::~RealChromosome()=default;RealChromosome &RealChromosome::operator=(const RealChromosome &c){if(this !=&c){gene=c.gene;fitness=c.fitness;}return *this;}bool RealChromosome::operator<(const RealChromosome &c)const{return fitness < c.fitness;}bool RealChromosome::operator==(const RealChromosome &other)const{if(gene.size()!=other.gene.size()){return false;}constexpr float epsilon=std::numeric_limits<float>::epsilon();for(size_t i=0;i < gene.size();++i){if(std::abs(gene[i] - other.gene[i])> epsilon){return false;}}return true;}std::string RealChromosome::toString()const{if(gene.empty()){return "[]";}std::ostringstream os;os.precision(10);os << "[";for(size_t i=0;i < gene.size()- 1;++i){os << gene[i] << ",";}os << gene.back()<< "]";return os.str();}float RealChromosome::distanceTo(const RealChromosome &g)const{if(gene.size()!=g.gene.size()){throw std::invalid_argument("Chromosomes must have same size for distance calculation");}float sse=0.0f;for(size_t i=0;i < gene.size();++i){const float dx=gene[i] - g.gene[i];sse +=dx * dx;}return std::sqrt(sse);}void RealChromosome::randUniform(vector<float> &lb,vector<float> &ub){for(size_t i=0;i < gene.size();i++){gene[i]=Stat::randUniform(lb[i],ub[i]);}}void RealChromosome::randUniform(int i,vector<float> &lb,vector<float> &ub){gene[i]=Stat::randUniform(lb[i],ub[i]);}void RealChromosome::randGaussian(float mean,float sigma,vector<float> &lb,vector<float> &ub){for(size_t i=0;i < gene.size();i++){gene[i]=Stat::randGaussian(mean,sigma);if(gene[i] < lb[i])gene[i]=lb[i];if(gene[i] > ub[i])gene[i]=ub[i];}}void RealChromosome::randGaussian(int i,float mean,float sigma,vector<float> &lb,vector<float> &ub){gene[i]=Stat::randGaussian(mean,sigma);if(gene[i] < lb[i])gene[i]=lb[i];if(gene[i] > ub[i])gene[i]=ub[i];}
 RouletteWheelSelection::RouletteWheelSelection(size_t populationSize){mNormalizedFitness.resize(populationSize);}RouletteWheelSelection::~RouletteWheelSelection(){}void RouletteWheelSelection::normalize(vector<float> &fitnessValues){RALG::minmax(fitnessValues,mMinFitnessValue,mMaxFitnessValue);for(size_t i=0;i < fitnessValues.size();i++){if(mMaxFitnessValue==mMinFitnessValue){mNormalizedFitness[i]=1.0f;}else{mNormalizedFitness[i]=(1.01f -(fitnessValues[i] - mMinFitnessValue)/(mMaxFitnessValue - mMinFitnessValue))/ 1.01f;}}}void RouletteWheelSelection::selectStochasticAcceptance(int &indexA,int &indexB){int n=mNormalizedFitness.size();while(1){indexA=Stat::randIndex(n);if(Stat::randUniform()< mNormalizedFitness[indexA]){break;}}while(1){indexB=Stat::randIndex(n);if(indexB==indexA)continue;if(Stat::randUniform()< mNormalizedFitness[indexB]){break;}}}void RouletteWheelSelection::select(vector<float> &fitnessValues,int &indexA,int &indexB){normalize(fitnessValues);selectStochasticAcceptance(indexA,indexB);}
 TournamentSelection::TournamentSelection(size_t populationSize){mTournamentSize=std::max(2,(int)((float)populationSize * 0.1f));mPopulationSize=populationSize;mSelectionProbability=0.85f;mTournamentFitness.resize(mTournamentSize);mTournamentIndex.resize(mTournamentSize);}TournamentSelection::~TournamentSelection()=default;void TournamentSelection::setTournamentSize(int tournamentSize){mTournamentSize=tournamentSize;mTournamentFitness.resize(mTournamentSize);mTournamentIndex.resize(mTournamentSize);}void TournamentSelection::setSelectionProbability(float selectionProbability){mSelectionProbability=selectionProbability;}void TournamentSelection::select(std::vector<float> &fitnessValues,int &indexA,int &indexB){indexA=tournament(fitnessValues);indexB=tournament(fitnessValues);while(indexA==indexB){indexA=tournament(fitnessValues);indexB=tournament(fitnessValues);}}int TournamentSelection::tournament(std::vector<float> &fitnessValues){int i=0;while(i < mTournamentSize){int index=Stat::randIndex(mPopulationSize);bool match=false;for(int j=0;j < i;j++){if(mTournamentIndex[j]==index){match=true;break;}}if(!match){mTournamentIndex[i]=index;mTournamentFitness[i]=fitnessValues[index];++i;}}int kth,localKthIndex,kthMinIndex;if(mSelectionProbability < 1.0f){float chooseP=mSelectionProbability;for(kth=1;kth < mTournamentSize;++kth){if(Stat::randUniform()< chooseP)break;chooseP *=(1.0f - mSelectionProbability);}localKthIndex=RALG::argKthSmallest(mTournamentFitness,0,mTournamentSize - 1,kth);kthMinIndex=mTournamentIndex[localKthIndex];}else{localKthIndex=RALG::argMin(mTournamentFitness.data(),0,mTournamentSize - 1);kthMinIndex=mTournamentIndex[localKthIndex];}return kthMinIndex;}
 RealGA::RealGA(){mFitnessFcn=nullptr;mGeneration=0;mSelectionAlgorithm=nullptr;mCrossover=nullptr;mMutation=nullptr;mGaussianMutationPerc=1.0f;mUniformMutationPerc=1.0f;}RealGA::~RealGA(){if(mCrossover !=nullptr){delete mCrossover;mCrossover=nullptr;}if(mSelectionAlgorithm !=nullptr){delete mSelectionAlgorithm;mSelectionAlgorithm=nullptr;}if(mMutation !=nullptr){delete mMutation;mMutation=nullptr;}}void RealGA::resetPopulation(){if(mOptions.populationSize !=mPopulation.size()){mPopulation.resize(mOptions.populationSize,mOptions.chromosomeSize);mNewPopulation.resize(mOptions.populationSize,mOptions.chromosomeSize);mFitnessValues.resize(mOptions.populationSize);}if(mPopulation.size()!=0){if(mOptions.chromosomeSize !=mPopulation[0].gene.size()){mPopulation.resize(mOptions.populationSize,mOptions.chromosomeSize);mNewPopulation.resize(mOptions.populationSize,mOptions.chromosomeSize);mFitnessValues.resize(mOptions.populationSize);}}}void RealGA::resetGaussianMutationPerc(){mGaussianMutationPerc=1.0f;mUniformMutationPerc=1.0f;}void RealGA::restart(){if(mOptions.mutationType==GAUSSIAN_MUTATION){resetGaussianMutationPerc();}mGeneration=0;}void RealGA::init(RealGAOptions &opt,FitnessFunction *func,bool keepState){mOptions=opt;mFitnessFcn=func;if(keepState){REALGA_ERROR(mPopulation.empty(),"reset is false,but chromosome population size is 0");REALGA_ERROR(mOptions.populationSize !=mPopulation.size(),"reset is false,but population size " << mPopulation.size()<< " is different from option population size " << mOptions.populationSize);REALGA_ERROR(mOptions.chromosomeSize !=mPopulation[0].gene.size(),"reset is false,but chromosome size " << mPopulation[0].gene.size()<< " is different from option chromosome size " << mOptions.chromosomeSize);}else{resetPopulation();if(mOptions.mutationType==GAUSSIAN_MUTATION){resetGaussianMutationPerc();}switch(mOptions.selectionType){case ROULETTE_WHEEL_SELECTION: mSelectionAlgorithm=new RouletteWheelSelection(mOptions.populationSize);break;case TOURNAMENT_SELECTION: mSelectionAlgorithm=new TournamentSelection(mOptions.populationSize);((TournamentSelection *)mSelectionAlgorithm)->setTournamentSize(mOptions.selectionTournamentSize);((TournamentSelection *)mSelectionAlgorithm)->setSelectionProbability(mOptions.selectionTournamentProbability);break;}REALGA_ERROR(mSelectionAlgorithm==nullptr,"SelectionAlgorithm is null");switch(mOptions.crossoverType){case UNIFORM_CROSSOVER: mCrossover=new UniformCrossover(mOptions.chromosomeSize);break;}REALGA_ERROR(mCrossover==nullptr,"Crossover is null");switch(mOptions.mutationType){case UNIFORM_MUTATION: mMutation=new UniformMutation(mOptions.mutationRate,mUniformMutationPerc);break;case GAUSSIAN_MUTATION: mMutation=new GaussianMutation(mOptions.mutationRate,mGaussianMutationPerc);break;}Stat::setSeed(mOptions.seed);mGeneration=0;mOptions.checkOptions();mLB=mOptions.lowerBounds;mUB=mOptions.upperBounds;}}void RealGA::setFitnessFunction(FitnessFunction *f){mFitnessFcn=f;}void RealGA::fillFitnessValues(vector<RealChromosome> &population){for(size_t i=0;i < population.size();i++){mFitnessValues[i]=population[i].fitness;}}int RealGA::getGeneration(){return mGeneration;}float RealGA::evalFitness(const RealChromosome &x){float eval=mFitnessFcn->eval(x);if(isnan(eval)|| isinf(eval)){return MAXFLOAT;}return eval;}RealChromosome RealGA::getBestChromosome(){int minIndex=0;float minValue=mPopulation[0].fitness;for(size_t i=1;i < mPopulation.size();i++){float value=mPopulation[i].fitness;if(value < minValue){minValue=value;minIndex=i;}}return mPopulation[minIndex];}const vector<RealChromosome> &RealGA::getPopulation()const{return mPopulation;}string RealGA::populationToString(){std::ostringstream os;os << "Population of Generation: " << mGeneration << "\n";for(size_t i=0;i < mOptions.populationSize;i++){os << i << ": " << mPopulation[i].toString()<< " -> Fitness " << mPopulation[i].fitness << "\n";}return os.str();}string RealGA::populationToCSVString(){std::ostringstream os;os << "id,";for(size_t i=0;i < mPopulation[i].gene.size();i++){os << "x" << i << ",";}os << "fitness\n";for(size_t i=0;i < mOptions.populationSize;i++){string geneString=mPopulation[i].toString();os << i << "," << geneString.substr(1,geneString.size()- 2)<< "," << mPopulation[i].fitness << "\n";}return os.str();}void RealGA::populationToCSV(const std::string &csvFilename){std::ofstream ofs(csvFilename);if(!ofs.is_open()){std::cerr << "Error: Could not open file " << csvFilename << " for writing." << std::endl;return;}ofs << populationToCSVString();ofs.close();}void RealGA::checkPopulation(){for(size_t i=0;i < mOptions.populationSize;i++){for(size_t j=0;j < mOptions.chromosomeSize;++j){REALGA_ERROR(isnan(mPopulation[i].gene[j])|| isinf(mPopulation[i].gene[j]),"error in chromosome " << i << " " << mPopulation[i].toString());}}}void RealGA::evolve(){RealChromosome offspring(mOptions.chromosomeSize);int selectedIndexA,selectedIndexB;size_t iter=0;int countElite=0;int elitismNumber=(int)(mOptions.elitismFactor * mOptions.populationSize);fillFitnessValues(mPopulation);float kthSmallestFitness=RALG::kthSmallest(mFitnessValues,0,mOptions.populationSize - 1,elitismNumber + 1);while(iter < mOptions.populationSize){if((mFitnessValues[iter] <=kthSmallestFitness)&&(countElite < elitismNumber)){mNewPopulation[iter]=mPopulation[iter];++iter;++countElite;continue;}mSelectionAlgorithm->select(mFitnessValues,selectedIndexA,selectedIndexB);mCrossover->crossover(mPopulation[selectedIndexA],mPopulation[selectedIndexB],offspring);mMutation->mutate(offspring,mLB,mUB);offspring.fitness=evalFitness(offspring);if(mOptions.mutateDuplicatedFitness){for(size_t j=0;j < iter;j++){if(fabs(offspring.fitness - mNewPopulation[j].fitness)< 1.0e-12){mMutation->mutate(offspring,mLB,mUB);offspring.fitness=evalFitness(offspring);}}}mNewPopulation[iter]=offspring;++iter;}if(mOptions.mutationType==GAUSSIAN_MUTATION){mGaussianMutationPerc=fmax(mOptions.mutationGaussianPercMin,1.0f - mOptions.mutationGaussianPercDelta *(float)mGeneration);mMutation->setMutationPercentage(mGaussianMutationPerc);}if(mOptions.mutationType==UNIFORM_MUTATION){mUniformMutationPerc=fmax(mOptions.mutationUniformPercMin,1.0f - mOptions.mutationUniformPercDelta *(float)mGeneration);mMutation->setMutationPercentage(mUniformMutationPerc);}mPopulation=mNewPopulation;mGeneration++;}void RealGA::popInitRandUniform(){for(size_t i=0;i < mOptions.populationSize;i++){mPopulation[i].randUniform(mLB,mUB);mPopulation[i].fitness=evalFitness(mPopulation[i]);}}void RealGA::popInitRandGaussian(float mean,float sigma){for(size_t i=0;i < mOptions.populationSize;i++){mPopulation[i].randGaussian(mean,sigma,mLB,mUB);mPopulation[i].fitness=evalFitness(mPopulation[i]);}}void RealGA::popInitGaussianMutate(vector<float> &gene,float mutatioRate,float mutationPerc){RealChromosome g(mOptions.chromosomeSize);GaussianMutation mutation(mutatioRate,mutationPerc);for(size_t i=0;i < mOptions.chromosomeSize;i++){g.gene[i]=gene[i];}mPopulation[0]=g;mPopulation[0].fitness=evalFitness(mPopulation[0]);for(size_t i=1;i < mOptions.populationSize;i++){mPopulation[i]=g;mutation.mutate(mPopulation[i],mLB,mUB);mPopulation[i].fitness=evalFitness(mPopulation[i]);}}void RealGA::popInitSetChromosome(unsigned int index,RealChromosome &chromosome){REALGA_ERROR(index >=mOptions.populationSize,"index " << index << " is out of range [0," << mOptions.populationSize << ")");for(size_t i=0;i < chromosome.gene.size();i++)REALGA_ERROR(chromosome.gene[i] < mLB[i] || chromosome.gene[i] > mUB[i],"chromosome " << chromosome.toString()<< " gene " << i << " is " << chromosome.gene[i]);mPopulation[index]=chromosome;mPopulation[index].fitness=evalFitness(mPopulation[index]);}void RealGA::popInitSetPopulation(vector<RealChromosome> &population){REALGA_ERROR(mPopulation.size()!=mOptions.populationSize,"size of population " << mPopulation.size()<< " is not the same as Np=" << mOptions.populationSize);mPopulation=population;}void RealGA::evaluatePopulationFitness(){for(size_t i=0;i < mOptions.populationSize;i++){mPopulation[i].fitness=evalFitness(mPopulation[i]);}}

