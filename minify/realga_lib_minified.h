//Original chars:  39922
//Minified chars:  24794
//minified/original:  62.11%
#define REALGA_ERROR(condition,msg){if(condition){cerr << "ERROR: " << __func__<< " \""<< msg<<"\" "<< " File: "<< __FILE__<< " Line:" << __LINE__<< endl;exit(-1);}}
#define MIN_SIGMA 1.0e-9f
#include<vector>
#include<limits>
#include<math.h>
#include<string>
#include<algorithm>
#include<iostream>
#include<stdlib.h>
#include<sstream>
#include<stdio.h>

class Stat{public: static float randUniform();static float randUniform(float lb,float ub);static float randGaussian(float m,float s);static int randIndex(int N);static void setSeed(unsigned int seed);};
using namespace std;namespace RALG{void realgaSwap(float &a,float &b);int partition(float arr[],int l,int r);float kthSmallest_(float arr[],int l,int r,int k);float kthSmallest(vector<float> &fitnessValues,int l,int r,int k);int argKthSmallest(vector<float> &fitnessValues,int l,int r,int k);int searchIndexBinarySearch(vector<float> arr,float x,int left,int right);void minmax(vector<float> arr,float &minValue,float &maxValue);int argMin(float arr[],int l,int r);int argSelection(float arr[],int l,int r,int kth);}
using namespace std;typedef enum{ROULETTE_WHEEL_SELECTION=1,TOURNAMENT_SELECTION}SelectionType;typedef enum{UNIFORM_CROSSOVER=1,SINGLE_POINT_CROSSOVER}CrossoverType;typedef enum{UNIFORM_MUTATION=1,GAUSSIAN_MUTATION}MutationType;typedef enum{NO_VERBOSE=0,SOFT_VERBOSE=1,HARD_VERBOSE=2}VerboseType;class RealGAOptions{public: RealGAOptions();~RealGAOptions();void setPopulationSize(int np);void setChromosomeSize(int nx);void setLowerBounds(const vector<float> &lb);void setUpperBounds(const vector<float> &ub);void setBounds(const vector<float> &lb,const vector<float> &ub);void setVerbose(string value);void setSeed(unsigned int seedValue);void setElitismFactor(float value);void setSelectionType(string value);void setSelectionTournamentSize(int value);void setSelectionTournamentProbability(float value);void setMutationType(string value);void setUniformMutationRate(float value);void setMutationRate(float value);void setMutationGaussianPerc(float percDelta,float percMin);void setCrossoverType(string value);void setSinglePointCrossoverIndex(int value);void checkOptions();int populationSize;int chromosomeSize;vector<float> lowerBounds;vector<float> upperBounds;int seed;VerboseType verbose;float elitismFactor;SelectionType selectionType;int selectionTournamentSize;float selectionTournamentProbability;CrossoverType crossoverType;int crossoverindexA;MutationType mutationType;float mutationRate;float mutationUniformPerc;float mutationGaussianPercDelta;float mutationGaussianPercMin;};
using namespace std;class RealChromosome{public: vector<float> gene;float fitness;RealChromosome();RealChromosome(int n);RealChromosome(const RealChromosome &c);~RealChromosome();string toString();void randUniform(vector<float> &lb,vector<float> &ub);void randUniform(int i,vector<float> &lb,vector<float> &ub);void uniformMutate(int i,float perc,vector<float> &lb,vector<float> &ub);void randGaussian(float mean,float sigma,vector<float> &lb,vector<float> &ub);void randGaussian(int i,float mean,float sigma,vector<float> &lb,vector<float> &ub);void gaussianMutate(int i,float perc,vector<float> &lb,vector<float> &ub);float distanceTo(RealChromosome &);RealChromosome & operator=(const RealChromosome &c);bool operator<(const RealChromosome &c)const;bool operator==(const RealChromosome &other)const;};
class FitnessFunction{public: virtual float eval(const RealChromosome &x)=0;virtual ~FitnessFunction(){};};
using namespace std;class Selection{public: virtual ~Selection(){}virtual void init(vector<float> &fitnessValues)=0;virtual void select(vector<float> &fitnessValues,int &indexA,int &indexB)=0;};class RouletteWheelSelection: public Selection{public: RouletteWheelSelection(int populationSize);~RouletteWheelSelection();void init(vector<float> &fitnessValues);void select(vector<float> &fitnessValues,int &indexA,int &indexB);private:vector<float> mNormalizedFitness;float mMinFitnessValue;float mMaxFitnessValue;void selectStochasticAcceptance(int &indexA,int &indexB);};class TournamentSelection: public Selection{public: TournamentSelection(int populationSize);~TournamentSelection();void setTournamentSize(int tournamentSize);void setSelectionProbability(float selectionProbability);void init(vector<float> &fitnessValues);void select(vector<float> &fitnessValues,int &indexA,int &indexB);int tournament(vector<float> &fitnessValues);private: int mTournamentSize;int mPopulationSize;float mSelectionProbability;float *mTournamentFitness;int *mTournamentIndex;};
using namespace std;class RealGA{public: RealGA();~RealGA();void restart();void init(RealGAOptions &opt,FitnessFunction *func,bool keepState);void setFitnessFunction(FitnessFunction *f);void resetPopulation();void resetGaussianMutationPerc();float evalFitness(const RealChromosome &);RealChromosome getBestChromosome();int getGeneration();vector<RealChromosome> getPopulation();void checkPopulation();string populationToString();void popInitRandUniform();void popInitRandGaussian(float mean,float sigma);void popInitGaussianMutate(vector<float> &gene,float mutatioRate,float perc);void popInitSetChromosome(unsigned int index,RealChromosome &chromosome);void popInitSetPopulation(vector<RealChromosome>&population);void crossoverUniform(int indexA,int indexB,RealChromosome & offspring);void crossoverFixed(int indexA,int indexB,RealChromosome &offspring,int splitIndex);void uniformMutate(RealChromosome &chromosome,float mutationRate,float perc);void gaussianMutate(RealChromosome &chromosome,float mutationRate,float perc);virtual void evolve();protected: vector<float> mLB;vector<float> mUB;vector<RealChromosome> mPopulation;vector<RealChromosome> mNewPopulation;RealGAOptions mOptions;FitnessFunction *mFitnessFcn;vector<float> mFitnessValues;float mKthSmallestFitness;int mElitismNumber;Selection *mSelectionAlgorithm;int mGeneration;float mGaussianPerc;void fillFitnessValues(vector<RealChromosome> &population);};
 float Stat::randUniform(){return(float)(rand()/(float(RAND_MAX)+ 1.0));}float Stat::randUniform(float lb,float ub){return(ub-lb)*randUniform()+ lb;}int Stat::randIndex(int N){return(int)(randUniform()*N);}float Stat::randGaussian(float m,float s){if(s < MIN_SIGMA){s=MIN_SIGMA;}float x1,x2,w,y1;static float y2;static int use_last=0;if(use_last){y1=y2;use_last=0;}else{do{x1=2.0 *(float)rand()/(RAND_MAX + 1.0)- 1.0;x2=2.0 *(float)rand()/(RAND_MAX + 1.0)- 1.0;w=x1 * x1 + x2 * x2;}while(w >=1.0);w=sqrt((-2.0 * log(w))/ w);y1=x1 * w;y2=x2 * w;use_last=1;}return(m + y1 * s);}void Stat::setSeed(unsigned int seed){srand(seed);}
 namespace RALG{void realgaSwap(float &a,float &b){float c=a;a=b;b=c;}int partition(float arr[],int l,int r){float x=arr[r];int i=l;for(int j=l;j <=r - 1;j++){if(arr[j] <=x){realgaSwap(arr[i],arr[j]);i++;}}realgaSwap(arr[i],arr[r]);return i;}float kthSmallest_(float arr[],int l,int r,int k){if(k > 0 && k <=r - l + 1){int index=partition(arr,l,r);if(index - l==k - 1)return arr[index];if(index - l > k - 1)return kthSmallest_(arr,l,index - 1,k);return kthSmallest_(arr,index + 1,r,k - index + l - 1);}return -1;}float kthSmallest(vector<float> &fitnessValues,int l,int r,int k){int n=fitnessValues.size();float *arr=new float[n];for(int i=0;i<n;i++){arr[i]=fitnessValues[i];}float kth=kthSmallest_(arr,l,r,k);delete []arr;return kth;}int argKthSmallest(vector<float> &fitnessValues,int l,int r,int k){int n=fitnessValues.size();float kth=kthSmallest(fitnessValues,l,r,k);int kthIndex=-1;for(int i=0;i<n;i++){if(kth==fitnessValues[i]){kthIndex=i;break;}}return kthIndex;}int searchIndexBinarySearch(vector<float> arr,float x,int left,int right){int l=left,r=right;int m=0;while(l < r){m=(r + l)/ 2;if(l==r){return m;}if(r==l+1){if(x > arr[l] && x < arr[r])return l;if(x > arr[r])return r;}if(arr[m]==x)return m;if(arr[m] < x)l=m;else r=m;}return m;}void minmax(vector<float> arr,float &minValue,float &maxValue){minValue=arr[0];maxValue=arr[0];for(int i=1;i<arr.size();i++){float v=arr[i];if(v < minValue)minValue=v;if(v > maxValue)maxValue=v;}}int argMin(float arr[],int l,int r){float minValue=arr[0];int minIndex=0;for(int i=l+1;i<=r;i++){if(arr[i] < minValue){minValue=arr[i];minIndex=i;}}return minIndex;}int argSelection(float arr[],int l,int r,int kth){float minValue;int minIndex;for(int k=0;k<kth;k++){minValue=arr[k];minIndex=k;for(int i=l+k+1;i<=r;i++){if(arr[i] < minValue){minValue=arr[i];minIndex=i;}}if(k<kth-1)realgaSwap(arr[k],arr[minIndex]);}return minIndex;}}
 RealGAOptions::RealGAOptions(){populationSize=100;chromosomeSize=-1;verbose=NO_VERBOSE;seed=42;elitismFactor=0.1;selectionType=ROULETTE_WHEEL_SELECTION;selectionTournamentSize=16;selectionTournamentProbability=0.85;crossoverType=UNIFORM_CROSSOVER;crossoverindexA=-1;mutationType=UNIFORM_MUTATION;mutationRate=0.1;mutationUniformPerc=0.25;mutationGaussianPercDelta=0.01;mutationGaussianPercMin=0.001;}RealGAOptions::~RealGAOptions(){}void RealGAOptions::setPopulationSize(int value){REALGA_ERROR(value <=0,"Population size must be > 0");populationSize=value;}void RealGAOptions::setChromosomeSize(int value){REALGA_ERROR(value <=0,"Chromosome size must be > 0");chromosomeSize=value;}void RealGAOptions::setLowerBounds(const vector<float> &lb){lowerBounds=lb;}void RealGAOptions::setUpperBounds(const vector<float> &ub){upperBounds=ub;}void RealGAOptions::setBounds(const vector<float> &lb,const vector<float> &ub){setLowerBounds(lb);setUpperBounds(ub);}void RealGAOptions::setVerbose(string value){if(value=="none")verbose=NO_VERBOSE;else if(value=="soft")verbose=SOFT_VERBOSE;else if(value=="hard")verbose=HARD_VERBOSE;else REALGA_ERROR(1,value << " is an invalid verbose type");}void RealGAOptions::setSeed(unsigned int value){seed=value;}void RealGAOptions::setSelectionType(string value){if(value=="roulette")selectionType=ROULETTE_WHEEL_SELECTION;else if(value=="tournament")selectionType=TOURNAMENT_SELECTION;else REALGA_ERROR(1,value << " is an invalid selection type");}void RealGAOptions::setSelectionTournamentSize(int value){REALGA_ERROR(value <=0,"Tournament size must be > 0");selectionTournamentSize=value;}void RealGAOptions::setSelectionTournamentProbability(float value){REALGA_ERROR((value<0.0)||(value>1.0),"tournament probability must be in [0,1]");selectionTournamentProbability=value;}void RealGAOptions::setElitismFactor(float value){REALGA_ERROR((value<0.0)||(value>1.0),"elitism factor must be in [0,1]");elitismFactor=value;}void RealGAOptions::setMutationType(string value){if(value=="uniform")mutationType=UNIFORM_MUTATION;else if(value=="gaussian")mutationType=GAUSSIAN_MUTATION;else REALGA_ERROR(1,value << " is an invalid mutation type");}void RealGAOptions::setUniformMutationRate(float value){REALGA_ERROR((value<0.0)||(value>1.0),"mutation rate must be in [0,1]");mutationUniformPerc=value;}void RealGAOptions::setMutationRate(float value){REALGA_ERROR((value<0.0)||(value>1.0),"mutation rate must be in [0,1]");mutationRate=value;}void RealGAOptions::setMutationGaussianPerc(float percDelta,float percMin){REALGA_ERROR((percDelta<0.0)||(percDelta>1.0),"gaussian mutation delta percentage must be in [0,1]");REALGA_ERROR((percMin<0.0)||(percMin>1.0),"gaussian mutation min percentage must be in [0,1]");mutationGaussianPercDelta=percDelta;mutationGaussianPercMin=percMin;}void RealGAOptions::setCrossoverType(string value){if(value=="uniform")crossoverType=UNIFORM_CROSSOVER;else if(value=="single_point")crossoverType=SINGLE_POINT_CROSSOVER;else REALGA_ERROR(1,value << " is an invalid crossover type");}void RealGAOptions::setSinglePointCrossoverIndex(int value){crossoverindexA=value;}void RealGAOptions::checkOptions(){REALGA_ERROR((lowerBounds.size()!=chromosomeSize),"lower bounds size "<<lowerBounds.size()<< " must equals chromosome size "<<chromosomeSize);REALGA_ERROR((upperBounds.size()!=chromosomeSize),"upper bounds size "<<upperBounds.size()<< " must equals chromosome size "<<chromosomeSize);if(crossoverType==SINGLE_POINT_CROSSOVER){REALGA_ERROR(((crossoverindexA<0)||(crossoverindexA>=chromosomeSize)),"index must be between 0 and " << chromosomeSize);}if(selectionType==TOURNAMENT_SELECTION){REALGA_ERROR(populationSize <=selectionTournamentSize,"tournament size "<< selectionTournamentSize << " must be less than population size " << populationSize);}}
 RealChromosome::RealChromosome(){fitness=0.0;}RealChromosome::RealChromosome(int n){gene.resize(n);}RealChromosome::RealChromosome(const RealChromosome &c){gene=c.gene;fitness=c.fitness;}RealChromosome::~RealChromosome(){}RealChromosome & RealChromosome::operator=(const RealChromosome &c){gene=c.gene;fitness=c.fitness;return *this;}bool RealChromosome::operator<(const RealChromosome &c)const{return fitness < c.fitness;}bool RealChromosome::operator==(const RealChromosome &other)const{if(gene.size()!=other.gene.size())return false;for(int i=0;i<other.gene.size();i++){if(gene[i] !=other.gene[i])return false;}return true;}string RealChromosome::toString(){std::ostringstream os;os.precision(10);os << "[";for(int i=0;i<gene.size()-1;i++){os << gene[i] << ",";}os << gene[gene.size()-1] << "]";return os.str();}float RealChromosome::distanceTo(RealChromosome &g){float sse=0.0;for(int i=0;i<gene.size();i++){float dx=gene[i]-g.gene[i];sse +=dx*dx;}return sqrt(sse);}void RealChromosome::randUniform(vector<float> &lb,vector<float> &ub){for(int i=0;i<gene.size();i++){gene[i]=Stat::randUniform(lb[i],ub[i]);}}void RealChromosome::randUniform(int i,vector<float> &lb,vector<float> &ub){gene[i]=Stat::randUniform(lb[i],ub[i]);}void RealChromosome::uniformMutate(int i,float perc,vector<float> &lb,vector<float> &ub){float fraction=perc*(Stat::randUniform()-0.5)*(ub[i]-lb[i]);gene[i] +=fraction;if(gene[i] < lb[i])gene[i]=lb[i];if(gene[i] > ub[i])gene[i]=ub[i];}void RealChromosome::randGaussian(float mean,float sigma,vector<float> &lb,vector<float> &ub){for(int i=0;i<gene.size();i++){gene[i]=Stat::randGaussian(mean,sigma);if(gene[i] < lb[i])gene[i]=lb[i];if(gene[i] > ub[i])gene[i]=ub[i];}}void RealChromosome::randGaussian(int i,float mean,float sigma,vector<float> &lb,vector<float> &ub){gene[i]=Stat::randUniform(lb[i],ub[i]);}void RealChromosome::gaussianMutate(int i,float perc,vector<float> &lb,vector<float> &ub){float delta=ub[i] - lb[i];float sigma=perc *(delta / 4.0f);float r=Stat::randGaussian(0.0,sigma);if(isnan(r)|| isinf(r)){r=0.0;}gene[i] +=r;if(gene[i] < lb[i])gene[i]=lb[i];if(gene[i] > ub[i])gene[i]=ub[i];}
 RouletteWheelSelection::RouletteWheelSelection(int populationSize){mNormalizedFitness.resize(populationSize);}RouletteWheelSelection::~RouletteWheelSelection(){}void RouletteWheelSelection::init(vector<float> &fitnessValues){RALG::minmax(fitnessValues,mMinFitnessValue,mMaxFitnessValue);for(int i=0;i< fitnessValues.size();i++){mNormalizedFitness[i]=(1.01f -(fitnessValues[i] - mMinFitnessValue)/(mMaxFitnessValue - mMinFitnessValue))/ 1.01f;}}void RouletteWheelSelection::selectStochasticAcceptance(int &indexA,int &indexB){int n=mNormalizedFitness.size();while(1){indexA=Stat::randIndex(n-1);if(Stat::randUniform()< mNormalizedFitness[indexA]){break;}}while(1){indexB=Stat::randIndex(n-1);if(indexB==indexA)continue;if(Stat::randUniform()< mNormalizedFitness[indexB]){break;}}}void RouletteWheelSelection::select(vector<float> &fitnessValues,int &indexA,int &indexB){selectStochasticAcceptance(indexA,indexB);}
 TournamentSelection::TournamentSelection(int populationSize){mTournamentSize=(int)(populationSize*0.1);mPopulationSize=populationSize;mSelectionProbability=0.85;}TournamentSelection::~TournamentSelection(){if(mTournamentFitness !=nullptr)delete []mTournamentFitness;if(mTournamentIndex !=nullptr)delete []mTournamentIndex;}void TournamentSelection::setTournamentSize(int tournamentSize){mTournamentSize=tournamentSize;}void TournamentSelection::setSelectionProbability(float selectionProbability){mSelectionProbability=selectionProbability;}void TournamentSelection::init(vector<float> &fitnessValues){mTournamentFitness=new float[mTournamentSize];mTournamentIndex=new int[mTournamentSize];}void TournamentSelection::select(vector<float> &fitnessValues,int &indexA,int &indexB){indexA=tournament(fitnessValues);indexB=tournament(fitnessValues);while(indexA==indexB){indexA=Stat::randIndex(fitnessValues.size()-1);indexB=Stat::randIndex(fitnessValues.size()-1);}}int TournamentSelection::tournament(vector<float> &fitnessValues){int i=0;bool match=false;while(i < mTournamentSize){int index=Stat::randIndex(mPopulationSize-1);match=false;for(int j=0;j<i;j++){if(mTournamentIndex[j]==index){match=true;break;}}if(!match){mTournamentIndex[i]=index;mTournamentFitness[i]=fitnessValues[index];i++;}}int kth;int kthMinIndex;int localKthIndex;if(mSelectionProbability < 1.0){float chooseP=mSelectionProbability;for(kth=1;kth<mTournamentSize;kth++){if(Stat::randUniform()< chooseP){break;}chooseP *=(1.0 - mSelectionProbability);}localKthIndex=RALG::argSelection(mTournamentFitness,0,mTournamentSize-1,kth);kthMinIndex=mTournamentIndex[localKthIndex];}else{localKthIndex=RALG::argMin(mTournamentFitness,0,mTournamentSize-1);kthMinIndex=mTournamentIndex[localKthIndex];}return kthMinIndex;}
 RealGA::RealGA(){mFitnessFcn=nullptr;mGeneration=0;mSelectionAlgorithm=nullptr;mGaussianPerc=1.0f;}RealGA::~RealGA(){delete mSelectionAlgorithm;}void RealGA::resetPopulation(){if(mOptions.populationSize !=mPopulation.size()){mPopulation.clear();mNewPopulation.clear();mPopulation.resize(mOptions.populationSize,mOptions.chromosomeSize);mNewPopulation.resize(mOptions.populationSize,mOptions.chromosomeSize);mFitnessValues.resize(mOptions.populationSize);}if(mPopulation.size()!=0){if(mOptions.chromosomeSize !=mPopulation[0].gene.size()){mPopulation.clear();mNewPopulation.clear();mPopulation.resize(mOptions.populationSize,mOptions.chromosomeSize);mNewPopulation.resize(mOptions.populationSize,mOptions.chromosomeSize);mFitnessValues.resize(mOptions.populationSize);}}}void RealGA::resetGaussianMutationPerc(){mGaussianPerc=1.0f;}void RealGA::restart(){if(mOptions.mutationType==GAUSSIAN_MUTATION){resetGaussianMutationPerc();}mGeneration=0;}void RealGA::init(RealGAOptions &opt,FitnessFunction *func,bool keepState){mOptions=opt;mFitnessFcn=func;if(keepState){if(mPopulation.size()==0){cerr << "ERROR: setOptions: reset is false,but chromosome population size is 0" << endl;exit(-1);}else if(mOptions.populationSize !=mPopulation.size()){cerr << "ERROR: setOptions: reset is false,but population size " << mPopulation.size()<< " is different from option population size " << mOptions.populationSize << endl;exit(-1);}if(mOptions.chromosomeSize !=mPopulation[0].gene.size()){cerr << "ERROR: setOptions: reset is false,but chromosome size " << mPopulation[0].gene.size()<< " is different from option chromosome size " << mOptions.chromosomeSize << endl;exit(-1);}}else{resetPopulation();if(mOptions.mutationType==GAUSSIAN_MUTATION){resetGaussianMutationPerc();}switch(mOptions.selectionType){case ROULETTE_WHEEL_SELECTION: mSelectionAlgorithm=new RouletteWheelSelection(mOptions.populationSize);break;case TOURNAMENT_SELECTION: mSelectionAlgorithm=new TournamentSelection(mOptions.populationSize);((TournamentSelection *)mSelectionAlgorithm)->setTournamentSize(mOptions.selectionTournamentSize);((TournamentSelection *)mSelectionAlgorithm)->setSelectionProbability(mOptions.selectionTournamentProbability);break;}Stat::setSeed(mOptions.seed);mGeneration=0;mOptions.checkOptions();mLB=mOptions.lowerBounds;mUB=mOptions.upperBounds;}mElitismNumber=(int)(mOptions.elitismFactor * mOptions.populationSize);}void RealGA::setFitnessFunction(FitnessFunction *f){mFitnessFcn=f;}void RealGA::fillFitnessValues(vector<RealChromosome> &population){for(int i=0;i<population.size();i++){mFitnessValues[i]=population[i].fitness;}}int RealGA::getGeneration(){return mGeneration;}float RealGA::evalFitness(const RealChromosome &x){return mFitnessFcn->eval(x);}RealChromosome RealGA::getBestChromosome(){RealChromosome best;int minIndex=0;float minValue=mPopulation[0].fitness;for(int i=0;i<mPopulation.size();i++){float value=mPopulation[i].fitness;if(value < minValue){minValue=value;minIndex=i;}}best=mPopulation[minIndex];return best;}vector<RealChromosome> RealGA::getPopulation(){return mPopulation;}string RealGA::populationToString(){std::ostringstream os;RealChromosome x;os << "==============Generation: " << mGeneration << "===================" << endl;for(int i=0;i<mOptions.populationSize;i++){x=mPopulation[i];os << "[" <<(i+1)<< "] : "<< x.toString()<< " -> Fitness " << x.fitness << endl;}return os.str();}void RealGA::checkPopulation(){for(int i=0;i < mOptions.populationSize;i++){for(int j=0;j < mOptions.chromosomeSize;++j){REALGA_ERROR(isnan(mPopulation[i].gene[j])||isinf(mPopulation[i].gene[j]),"error in chromosome "<<i<<" "<<mPopulation[i].toString());}}}void RealGA::evolve(){RealChromosome offspring(mOptions.chromosomeSize);int selectedIndexA,selectedIndexB;int k=0;int countElite=0;fillFitnessValues(mPopulation);mKthSmallestFitness=RALG::kthSmallest(mFitnessValues,0,mOptions.populationSize-1,mElitismNumber+1);mSelectionAlgorithm->init(mFitnessValues);while(k < mOptions.populationSize){if((mFitnessValues[k] < mKthSmallestFitness)&&(countElite <=mElitismNumber)){mNewPopulation[k]=mPopulation[k];++k;++countElite;continue;}mSelectionAlgorithm->select(mFitnessValues,selectedIndexA,selectedIndexB);switch(mOptions.crossoverType){case UNIFORM_CROSSOVER: crossoverUniform(selectedIndexA,selectedIndexB,offspring);break;case SINGLE_POINT_CROSSOVER: crossoverFixed(selectedIndexA,selectedIndexB,offspring,mOptions.crossoverindexA);break;}if(mOptions.mutationType==UNIFORM_MUTATION){uniformMutate(offspring,mOptions.mutationRate,mOptions.mutationUniformPerc);}else if(mOptions.mutationType==GAUSSIAN_MUTATION){gaussianMutate(offspring,mOptions.mutationRate,mGaussianPerc);}offspring.fitness=evalFitness(offspring);for(int j=0;j<k;j++){if(offspring.fitness==mNewPopulation[j].fitness){if(mOptions.mutationType==UNIFORM_MUTATION){uniformMutate(offspring,1.0,mOptions.mutationUniformPerc);}else if(mOptions.mutationType==GAUSSIAN_MUTATION){gaussianMutate(offspring,1.0,mGaussianPerc);}offspring.fitness=evalFitness(offspring);}}mNewPopulation[k]=offspring;++k;}if(mOptions.mutationType==GAUSSIAN_MUTATION){if(mGaussianPerc > mOptions.mutationGaussianPercMin){mGaussianPerc=1.0f - mOptions.mutationGaussianPercDelta*(float)mGeneration;}else{mGaussianPerc=mOptions.mutationGaussianPercMin;}}for(int i=0;i<mPopulation.size();i++){mPopulation[i]=mNewPopulation[i];}mGeneration++;}void RealGA::popInitRandUniform(){for(int i=0;i<mOptions.populationSize;i++){mPopulation[i].randUniform(mLB,mUB);mPopulation[i].fitness=evalFitness(mPopulation[i]);}}void RealGA::popInitRandGaussian(float mean,float sigma){for(int i=0;i<mOptions.populationSize;i++){mPopulation[i].randGaussian(mean,sigma,mLB,mUB);mPopulation[i].fitness=evalFitness(mPopulation[i]);}}void RealGA::popInitGaussianMutate(vector<float> &gene,float mutatioRate,float perc){RealChromosome g(mOptions.chromosomeSize);for(int i=0;i<mOptions.chromosomeSize;i++){g.gene[i]=gene[i];}mPopulation[0]=g;mPopulation[0].fitness=evalFitness(mPopulation[0]);for(int i=1;i<mOptions.populationSize;i++){mPopulation[i]=g;gaussianMutate(mPopulation[i],mutatioRate,perc);mPopulation[i].fitness=evalFitness(mPopulation[i]);}}void RealGA::popInitSetChromosome(unsigned int index,RealChromosome &chromosome){if(index >=mOptions.populationSize){cerr << "ERROR: popInitSetChromosome: index " << index << " is out of range [0," << mOptions.populationSize << ")" << endl;}else{mPopulation[index]=chromosome;}}void RealGA::popInitSetPopulation(vector<RealChromosome> &population){if(mPopulation.size()!=mOptions.populationSize){cerr << "ERROR: popInitSetPopulation: size of population " << mPopulation.size()<< " is not the same as Np=" << mOptions.populationSize << endl;}else{mPopulation=population;}}void RealGA::crossoverUniform(int indexA,int indexB,RealChromosome &offspring){for(int j=0;j<mOptions.chromosomeSize;j++){if(Stat::randUniform()<0.5){offspring.gene[j]=mPopulation[indexA].gene[j];}else{offspring.gene[j]=mPopulation[indexB].gene[j];}}}void RealGA::crossoverFixed(int indexA,int indexB,RealChromosome &offspring,int splitIndex){for(int i=0;i<splitIndex;i++){offspring.gene[i]=mPopulation[indexA].gene[i];}for(int i=splitIndex;i<mOptions.chromosomeSize;i++){offspring.gene[i]=mPopulation[indexB].gene[i];}}void RealGA::uniformMutate(RealChromosome &chromosome,float mutationRate,float perc){for(int i=0;i<mOptions.chromosomeSize;i++){if(Stat::randUniform()< mutationRate){chromosome.uniformMutate(i,perc,mLB,mUB);}}}void RealGA::gaussianMutate(RealChromosome &chromosome,float mutationRate,float perc){for(int j=0;j<mOptions.chromosomeSize;j++){if(Stat::randUniform()< mutationRate){chromosome.gaussianMutate(j,perc,mLB,mUB);}}}

